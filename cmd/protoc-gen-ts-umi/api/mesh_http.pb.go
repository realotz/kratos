// Code generated by protoc-gen-go-http. DO NOT EDIT.

package v1

import (
	context "context"
	http1 "github.com/go-kratos/kratos/v2/transport/http"
	http "net/http"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
// context./http.
const _ = http1.SupportPackageIsVersion1

type MeshHTTPServer interface {
	CheckInfo(context.Context, *Request) (*Response, error)

	CreateGateway(context.Context, *Gateway) (*Response, error)

	DeleteGateway(context.Context, *DeleteKind) (*Response, error)

	GetGateway(context.Context, *GetKind) (*Gateway, error)

	GetGatewayList(context.Context, *ListOption) (*GatewayList, error)

	UpdateGateway(context.Context, *Gateway) (*Response, error)
}

func RegisterMeshHTTPServer(s http1.ServiceRegistrar, srv MeshHTTPServer) {
	s.RegisterService(&_HTTP_Mesh_serviceDesc, srv)
}

func _HTTP_Mesh_CheckInfo_0(srv interface{}, ctx context.Context, req *http.Request, dec func(interface{}) error) (interface{}, error) {
	var in Request

	if err := http1.BindForm(req, &in); err != nil {
		return nil, err
	}

	out, err := srv.(MeshServer).CheckInfo(ctx, &in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _HTTP_Mesh_GetGatewayList_0(srv interface{}, ctx context.Context, req *http.Request, dec func(interface{}) error) (interface{}, error) {
	var in ListOption

	if err := http1.BindForm(req, &in); err != nil {
		return nil, err
	}

	out, err := srv.(MeshServer).GetGatewayList(ctx, &in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _HTTP_Mesh_GetGateway_0(srv interface{}, ctx context.Context, req *http.Request, dec func(interface{}) error) (interface{}, error) {
	var in GetKind

	if err := http1.BindForm(req, &in); err != nil {
		return nil, err
	}

	out, err := srv.(MeshServer).GetGateway(ctx, &in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _HTTP_Mesh_CreateGateway_0(srv interface{}, ctx context.Context, req *http.Request, dec func(interface{}) error) (interface{}, error) {
	var in Gateway

	if err := dec(&in); err != nil {
		return nil, err
	}

	out, err := srv.(MeshServer).CreateGateway(ctx, &in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _HTTP_Mesh_UpdateGateway_0(srv interface{}, ctx context.Context, req *http.Request, dec func(interface{}) error) (interface{}, error) {
	var in Gateway

	if err := dec(&in); err != nil {
		return nil, err
	}

	out, err := srv.(MeshServer).UpdateGateway(ctx, &in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _HTTP_Mesh_DeleteGateway_0(srv interface{}, ctx context.Context, req *http.Request, dec func(interface{}) error) (interface{}, error) {
	var in DeleteKind

	if err := http1.BindForm(req, &in); err != nil {
		return nil, err
	}

	out, err := srv.(MeshServer).DeleteGateway(ctx, &in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _HTTP_Mesh_serviceDesc = http1.ServiceDesc{
	ServiceName: "cratos.api.v1.Mesh",
	Methods: []http1.MethodDesc{

		{
			Path:    "/cratos.api.v1.Mesh/CheckInfo",
			Method:  "GET",
			Handler: _HTTP_Mesh_CheckInfo_0,
		},

		{
			Path:    "/cratos.api.v1.Mesh/GetGatewayList",
			Method:  "GET",
			Handler: _HTTP_Mesh_GetGatewayList_0,
		},

		{
			Path:    "/cratos.api.v1.Mesh/GetGateway",
			Method:  "GET",
			Handler: _HTTP_Mesh_GetGateway_0,
		},

		{
			Path:    "/cratos.api.v1.Mesh/CreateGateway",
			Method:  "POST",
			Handler: _HTTP_Mesh_CreateGateway_0,
		},

		{
			Path:    "/cratos.api.v1.Mesh/UpdateGateway",
			Method:  "POST",
			Handler: _HTTP_Mesh_UpdateGateway_0,
		},

		{
			Path:    "/cratos.api.v1.Mesh/DeleteGateway",
			Method:  "DELETE",
			Handler: _HTTP_Mesh_DeleteGateway_0,
		},
	},
	Metadata: "mesh.proto",
}
